### 前言
***原文链接：https://netty.io/wiki/user-guide-for-4.x.html***

#### 问题

现在我们使用通用的应用程序或库相互通信。例如，我们经常使用一个HTTP客户端库来从一个web服务器上检索信息和通过web服务进行远程过程调用。然而，一个通用的协议或者它的实现有时候伸缩性并不是很好。这就像我们不能使用通用的HTTP服务器去交换大文件、e-mail信息和接近实时的消息，比如金融信息和多人游戏数据。所需要的是一个高度优化的协议实现，它专门用于一个特殊用途。例如，你可能想要实现针对基于AJAX的聊天应用程序，媒体流或大型文件传输进行优化的HTTP服务器。你甚至想设计和实现一种完全根据自己的需要定制的全新协议。另一个不可避免的情况是，您必须处理遗留的专有协议，以确保与旧系统的互操作性。在这种情况下，重要的是我们能够在不牺牲最终应用程序的稳定性和性能下多快地实现该协议。

### 解决方案

[Netty项目](http://netty.io/)是为了提供一个异步事件驱动的网络应用程序框架和工具，以快速开发可维护的高性能·高可伸缩性协议服务器和客户端。

换句话说，Netty是一个NIO客户端服务器框架，使开发者能够快速并且容易地开发网络应用程序，比如协议服务器和客户端。它极大地简化了网络编程，比如TCP和UDP套接字服务器端程序开发。

'快速和简单'并不意味着将导致应用程序出现可维护性和性能方面的问题。Netty的设计借鉴了许多协议的实现经验，例如FTP, SMTP, HTTP，以及各种二进制和基于文本的遗留协议。因此，Netty成功地找到了一种方法可以实现轻松的开发，并保证程序的性能，稳定性和灵活性，而无需妥协。

一些用户可能已经找到了其他声称拥有相同优势的网络应用程序框架，你可能会问，是什么让Netty与他们如此不同。答案就是它是以哲学为基础的。从第一天开始Netty就为您提供最舒适的API和实现。这不是什么有形的东西，但你会意识到，当你阅读这本指南并与使用Netty时，这种哲学会让你的生活变得更加容易。

### 开始
本章介绍了Netty的核心构造，通过简单的例子，让您快速入门。当你看到本章最后时，你将立即可以使用Netty写一个客户端和一个服务器。

如果你更喜欢自顶向下的方式学习知识，那么可以从第2章开始，它主要概述了Netty的结构，然后再回到这里。

#### 在开始之前
在本章中运行示例的最低要求只有两个：最新版本的Netty和JDK 1.6或以上版本。Netty的最新版本在[项目下载页](http://netty.io/downloads.html)可以获得。要下载正确版本的JDK，请到JDK供应商的官网下载。

当你阅读时，可能会对本章介绍的类有很多疑问。当你想了解它们更多信息时，请查阅API文档。这个文档中的所有类都已经链接到在线的API文档上，你可以很方便的查看。并且，如果有任何的错误信息、错误的语法和排版，或者有好多主意来改善文档，请不要犹豫地联系[Netty项目社区](http://netty.io/community.html)让我们知道。

#### 写一个丢弃服务
世界上最简单的协议不是'Hello, World!'，而是[DISCARD](https://tools.ietf.org/html/rfc863)。他就是一个丢弃任何接收到的数据和没有任何响应的协议。

为了实现DISCARD协议，你惟一需要做的就是忽略所有接收到的数据。让我们直接从handler实现开始，它处理由Netty生成的I/O事件。

```
package io.netty.example.discard;

import io.netty.buffer.ByteBuf;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;

/**
 1. Handles a server-side channel.
 */
public class DiscardServerHandler extends ChannelInboundHandlerAdapter { // (1)

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) { // (2)
        // Discard the received data silently.
        ((ByteBuf) msg).release(); // (3)
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // (4)
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
```

 2. DiscardServerHandle继承了实现了[ChannelInboundHandler](http://netty.io/4.1/api/io/netty/channel/ChannelInboundHandler.html)接口的[ChannelInboundHandlerAdapter](http://netty.io/4.1/api/io/netty/channel/ChannelInboundHandlerAdapter.html)。[ChannelInboundHandler](http://netty.io/4.1/api/io/netty/channel/ChannelInboundHandler.html)提供了可以重写的各种事件处理方法。目前，继承[ChannelInboundHandlerAdapter](http://netty.io/4.1/api/io/netty/channel/ChannelInboundHandlerAdapter.html)类就足够了，而不用自己去实现处理器接口。
 3. 这里，我们重写了事件处理方法channelRead()。每当从客户端接收到新消息时，就会把接收的消息作为参数，并调用此方法。在这个例子中，收到的消息类型是[ByteBuf](http://netty.io/4.1/api/io/netty/buffer/ByteBuf.html)。

 3. 为了实现DISCARD 协议，处理器不得不忽略接收到的消息。[ByteBuf](http://netty.io/4.1/api/io/netty/buffer/ByteBuf.html)是一个引用计数对象，必须通过release()方法显式地释放它。请牢记，传递到处理器中的任何引用计数对象，处理器都有责任释放它。通常channelRead()处理方法的实现如下：

```
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    try {
        // Do something with msg
    } finally {
        ReferenceCountUtil.release(msg);
    }
}
```

 4. 当Netty由于一个I/O错误或者处理器程序处理事件时抛出异常的原因而抛出异常时，带有Throwable参数的exceptionCaught事件处理方法会调用。在大多数情况下，尽管此方法的实现可以根据处理异常情况的需要而有所不同，但是应该记录捕获的异常，并在这里关闭它的关联通道。例如，你想在关闭连接前发送一个响应消息和错误码。

到目前为止一切顺利。我们已经实现了DISCARD服务器的前半部分。接下来就是写main()方法，和DiscardServerHandler一起开启服务器。

```
package io.netty.example.discard;
    
import io.netty.bootstrap.ServerBootstrap;

import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
    
/**
 1. Discards any incoming data.
 */
public class DiscardServer {
    
    private int port;
    
    public DiscardServer(int port) {
        this.port = port;
    }
    
    public void run() throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1)
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap(); // (2)
            b.group(bossGroup, workerGroup)
             .channel(NioServerSocketChannel.class) // (3)
             .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ch.pipeline().addLast(new DiscardServerHandler());
                 }
             })
             .option(ChannelOption.SO_BACKLOG, 128)          // (5)
             .childOption(ChannelOption.SO_KEEPALIVE, true); // (6)
    
            // 绑定并开始接受进来的连接
            ChannelFuture f = b.bind(port).sync(); // (7)
    
            // 等待直到server socket被关闭。
            // 在这个例子中，这是不会发生的，但是你可以优雅地关闭你的服务器。
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
    
    public static void main(String[] args) throws Exception {
        int port;
        if (args.length > 0) {
            port = Integer.parseInt(args[0]);
        } else {
            port = 8080;
        }
        new DiscardServer(port).run();
    }
}
```
 2. [NioEventLoopGroup](http://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html)是一个处理I/O操作的多线程事件循环。Netty对于不同的传输协议提供了不同的[EventLoopGroup](http://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html)实现。在本例中，我们正在实现一个服务器端应用程序，因此将使用两个[NioEventLoopGroup](http://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html)。第一个经常被称为'boss'，接受传入的连接。第二个经常被称为'worker'，当boss接受连接，并且注册这个连接到worker时，处理接受连接的流量。使用多少线程以及如何将它们映射到创建的[Channel](http://netty.io/4.1/api/io/netty/channel/Channel.html)s依赖于[EventLoopGroup](http://netty.io/4.1/api/io/netty/channel/nio/NioEventLoopGroup.html)的实现，甚至可以通过构造器进行配置。
 3. [ServerBootStrap](http://netty.io/4.1/api/io/netty/bootstrap/ServerBootstrap.html)是一个帮助器类，用于设置服务器。你可以直接使用[Channel](http://netty.io/4.1/api/io/netty/channel/Channel.html)来设置服务器。然而，请注意，这个一个冗长的过程，在大多数情况下你不需要这样做。
 4.  这里，我们指定使用NioServerSocketChannel类来实例化一个新的[Channel](http://netty.io/4.1/api/io/netty/channel/Channel.html)，用于接受传入的连接。
 5. 这里被指定的处理器将总是由最新接受的Channel评估。[ChannelInitializer](http://netty.io/4.1/api/io/netty/channel/ChannelInitializer.html)是个特殊的处理器，用于帮助用户配置一个新的[Channel](http://netty.io/4.1/api/io/netty/channel/Channel.html)。你很可能想配置新[Channel](http://netty.io/4.1/api/io/netty/channel/Channel.html)的[ChannelPipeline](http://netty.io/4.1/api/io/netty/channel/ChannelPipeline.html)，通过添加一些处理器（比如DiscardServerHandler）来实现你的网络应用程序。随着应用程序变得复杂，您可能会向管道中添加更多的处理程序，并最终将这个匿名类提取到顶级类中。
 6. 你也可以设置[Channel](http://netty.io/4.1/api/io/netty/channel/Channel.html)实现的相关的参数。我们写了一个TCP/IP服务器，因此我们可以设置socket选项，例如tcpNoDelay和keepAlive。请参考[ChannelOption](http://netty.io/4.1/api/io/netty/channel/ChannelOption.html)的API文档和具体的[ChannelConfig](http://netty.io/4.1/api/io/netty/channel/ChannelConfig.html)实现，从而有一个关于被支持的ChannelOptionS的总体认识。
 7. 你有注意到option()和chaildOption()吗？option()是用于接受传入连接的[NioServerSocketChannel](http://netty.io/4.1/api/io/netty/channel/socket/nio/NioServerSocketChannel.html)。childOption()是用于通过父[ServerChannel](http://netty.io/4.1/api/io/netty/channel/ServerChannel.html)接受的[Channel](http://netty.io/4.1/api/io/netty/channel/Channel.html)s，在这个例子中是[NioServerSocketChannel](http://netty.io/4.1/api/io/netty/channel/socket/nio/NioServerSocketChannel.html)。
 8. 我们现在准备好了。剩下的就是绑定端口和开启服务器。这里，我们绑定了在机器中的所有NICs（网络接口卡）的8080端口。现在你可以调用任意多次bind()方法（绑定不同的端口）。

恭喜你！你已经完成了你的第一个基于Netty的服务器。

#### 查看接收到的数据
现在我们已经写了第一个服务器，需要测试它是否能够真正的工作。最容易的测试方式是使用Telnet命令。例如，例如，你可以在命令行中输入telnet localhost 8080并输入内容。

然而，我们能说服务器运行正常吗？我们不能真正的知道，因为它是一个丢弃服务器。你将不能得到任何的响应。为了证明它能工作，让我们来改变服务器输出它已经接收的消息。

我们早就知道每当有数据接收时channelRead()就会被调用。在DiscardServerHandler类中的channelRead()方法里面添加一些代码：

```
@Override
public void channelRead(ChannelHandlerContext ctx, Object msg) {
    ByteBuf in = (ByteBuf) msg;
    try {
        while (in.isReadable()) { // (1)
            System.out.print((char) in.readByte());
            System.out.flush();
        }
    } finally {
        ReferenceCountUtil.release(msg); // (2)
    }
}
```

 1. 这个低效的循环实际上可以简化为：System.out.println(in.toString(io.netty.util.CharsetUtli.US_ASCII))
 2. 或者你可以使用in.release()

如果再次运行telnet命令，你将看到服务器输出接收到的数据。

丢弃服务器的完整源代码存储在发行的[io.netty.example.discard](http://netty.io/4.1/xref/io/netty/example/discard/package-summary.html)包下。

#### 写一个Echo服务器

到目前为止，我们一直在使用数据而没有任何响应。然而，服务器通常应该响应请求。让我们通过实现[ECHO](https://tools.ietf.org/html/rfc862)协议来学习如何返回响应消息到客户端，收到的任何数据将被发送回去。

与前面几节我们实现的丢弃服务器唯一不同的是，它把接收到的数据发送回去而不是打印到控制台。因此重新改变下channelRead()方法就够了:

```
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.write(msg); // (1)
        ctx.flush(); // (2)
    }
```

 1. 一个[ChannelHandlerContext](http://netty.io/4.1/api/io/netty/channel/ChannelHandlerContext.html)对象提供了能使你触发不同I/O事件和操作的不同操作。这里，我们调用write(Object)来逐字写入接收到的消息。请注意，我们并没有像在DISCARD例子中那样释放接收到的消息。当它被写出来时，Netty会为你释放它。
 2. ctx.write(Object)不会将消息写出来。它会内部缓存，然后通过ctx.flush()刷新出去。或者你可以使用更简洁的方式调用:ctx.writeAndFlush(msg)。

如果你再次运行telnet命令，你将看到服务器返回你发送给它的任何内容。

echo服务器的完整源代码存储在[io.netty.example.echo](http://netty.io/4.1/xref/io/netty/example/echo/package-summary.html)包下面。




